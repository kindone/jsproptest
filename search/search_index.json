{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#jsproptest","title":"jsproptest","text":"<p>Current Version: 0.5.3</p> <p><code>jsproptest</code> is a property-based testing (PBT) framework for JavaScript and TypeScript, drawing inspiration from libraries such as Haskell's QuickCheck and Python's Hypothesis. Property-based testing shifts the focus from example-based verification to defining universal properties or invariants that must hold true for an input domain.</p> <p>Instead of manually crafting test cases for specific inputs, PBT allows you to describe the domain of inputs your function expects and the general characteristics of the output (e.g., <code>add(a, b)</code> should always be greater than or equal to <code>a</code> and <code>b</code> if they are non-negative). PBT then generates hundreds or thousands of varied inputs, searching for edge cases or unexpected behaviors that violate your defined properties. This approach significantly increases test coverage and the likelihood of finding subtle bugs.</p> <p>The core workflow involves:</p> <ol> <li>Defining a property: A function that takes generated inputs and asserts an expected invariant. See Properties.</li> <li>Specifying generators: Mechanisms for creating random data conforming to certain types or constraints, often built by composing simpler generators using combinators. See Generators and Combinators.</li> <li>Execution: <code>jsproptest</code> automatically runs the property function against numerous generated inputs (typically 100+).</li> <li>Shrinking: If a test case fails (the property returns <code>false</code> or throws), <code>jsproptest</code> attempts to find a minimal counterexample by simplifying the failing input. See Shrinking.</li> </ol> <p>Consider verifying a round-trip property for a custom parser/serializer:</p> <pre><code>import { forAll, Gen } from 'jsproptest';\nimport { deepStrictEqual } from 'assert'; // Use Node.js assert for deep equality\n\nit('should preserve data after serializing and parsing', () =&gt; {\n  // Generator for keys (non-empty strings without '&amp;' or '=')\n  const keyGen = Gen.string(1, 10).filter(s =&gt; s.length &gt; 0 &amp;&amp; !s.includes('&amp;') &amp;&amp; !s.includes('='));\n  // Generator for arbitrary string values\n  const valueGen = Gen.string(0, 10);\n  // Generator for objects (dictionaries) with our specific keys and values\n  const dataObjectGen = Gen.dict(keyGen, valueGen, 0, 10);\n\n  // forAll executes the property check with generated data objects\n  forAll(\n    (originalData: Record&lt;string, string&gt;) =&gt; {\n      // Perform the round trip: serialize then parse\n      const serialized = serializeMyDataFormat(originalData);\n      const parsedData = parseMyDataFormat(serialized);\n\n      // Property: The parsed data must deep-equal the original data object.\n      // Using deepStrictEqual ensures type and value equality.\n      deepStrictEqual(parsedData, originalData);\n    },\n    dataObjectGen // Use the dictionary generator\n  );\n  // jsproptest runs this property multiple times with diverse data objects.\n});\n</code></pre> <p>This PBT approach facilitates the discovery of edge cases and intricate bugs that might be neglected by traditional, example-driven testing methodologies.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<p>To add <code>jsproptest</code> to your project, run the following command:</p> <p><pre><code>npm install jsproptest --save-dev\n</code></pre> This will install the package and add it to your <code>devDependencies</code>.</p>"},{"location":"#core-concepts-and-features","title":"Core Concepts and Features","text":"<p>Understanding these key components will help you use <code>jsproptest</code> effectively:</p> <ul> <li> <p>Generators: Produce random data of various types (primitives, containers) according to specified constraints (e.g., <code>Gen.integer()</code>, <code>Gen.array(...)</code>). Learn how to create the basic building blocks of your test data.</p> </li> <li> <p>Combinators: Modify or combine existing generators to create new ones. Discover techniques to constraint, combine, and transform generators for complex data structures.</p> </li> <li> <p>Properties (<code>Property</code>, <code>forAll</code>): Express conditions or invariants that should hold true for generated data. <code>jsproptest</code> runs these properties against many generated examples using the <code>forAll</code> function or <code>Property</code> class methods. Understand how to define the invariants your code should satisfy and how to run tests.</p> </li> <li> <p>Shrinking: When a property fails, <code>jsproptest</code> attempts to find a minimal counterexample by simplifying the failing input using logic associated with the generated value (often via a <code>Shrinkable</code> structure). See how <code>jsproptest</code> helps pinpoint failures.</p> </li> <li> <p>Stateful Testing: Go beyond simple input-output functions and test systems with internal state by generating sequences of operations or commands. Learn how to model and verify stateful behaviors.</p> </li> </ul>"},{"location":"combinators/","title":"Combinators","text":"<p>Combinators are higher-order functions that manipulate or combine existing generators (<code>Gen</code>) to create new, more sophisticated generators. They are the primary mechanism in <code>jsproptest</code> for building generators that produce complex data structures, implement specific constraints, or tailor data generation to the precise needs of your tests. Instead of just using basic generators like <code>Gen.number()</code> or <code>Gen.string()</code>, combinators allow you to compose these building blocks into generators for custom objects, arrays with specific properties, or data distributions that mimic real-world scenarios. Mastering combinators is key to unlocking the full potential of property-based testing.</p>"},{"location":"combinators/#combinator-summary-table","title":"Combinator Summary Table","text":"Combinator Description Key Parameters Example Usage Selection <code>Gen.oneOf(...gens)</code> Randomly picks one generator from <code>gens</code> to produce a value. Use <code>weightedGen</code> to adjust probabilities. <code>...generators</code> (can be <code>Weighted</code>) <code>Gen.oneOf(Gen.interval(0, 10), Gen.interval(20,30))</code> (Union of ranges) <code>Gen.elementOf(...values)</code> Randomly picks one value from the provided <code>values</code>. Use <code>weightedValue</code> to adjust probabilities. <code>...values</code> (can be <code>Weighted</code>) <code>Gen.elementOf(2, 3, 5, 7)</code> (Prime numbers &lt; 10) <code>Gen.weightedGen(gen, weight)</code> Wraps a generator with a <code>weight</code> for <code>Gen.oneOf</code>. <code>generator</code>, <code>weight</code> <code>Gen.weightedGen(Gen.string(), 0.8)</code> (80% probability) <code>Gen.weightedValue(value, weight)</code> Wraps a value with a <code>weight</code> for <code>Gen.elementOf</code>. <code>value</code>, <code>weight</code> <code>Gen.weightedValue('a', 0.2)</code> (20% probability) Transformation <code>generator.map(f)</code> Applies function <code>f</code> to each generated value. <code>(value: T) =&gt; U</code> <code>Gen.interval(1,100).map(n =&gt; n.toString())</code> (Stringified numbers within [1,100]) <code>generator.filter(predicate)</code> Only keeps values where <code>predicate(value)</code> is true. <code>(value: T) =&gt; boolean</code> <code>Gen.integer().filter(n =&gt; n % 2 === 0)</code> (Even numbers) <code>generator.flatMap(f)</code> / <code>generator.chain(f)</code> Creates a dependent generator using <code>f(value)</code> which returns a new Gen. <code>(value: T) =&gt; Arbitrary&lt;U&gt;</code> <code>Gen.inRange(1,5).flatMap(n =&gt; Gen.string(n))</code> (String of random length within [1,5)) Sequence Building <code>generator.accumulate(nextGen, minL, maxL)</code> Builds array where <code>nextGen(lastValue)</code> creates the next element. <code>nextGen</code>, <code>minL</code>, <code>maxL</code> (Chess move based on previous configuration) <code>generator.aggregate(nextGen, minL, maxL)</code> Builds array where <code>nextGen(currentArray)</code> creates the next array. <code>nextGen</code>, <code>minL</code>, <code>maxL</code> (Chess moves aggregated each based on previous configuration) Tuple Chaining <code>Gen.chainTuple(tupleGen, nextGen)</code> Appends result of <code>nextGen(tuple)</code> to the tuple from <code>tupleGen</code>. <code>tupleGen</code>, <code>nextGen</code> <code>Gen.chainTuple(yearMonthTupleGen, ([y,m]) =&gt; dayGen(y,m))</code> [Y,M,D] <code>tupleGen.chainAsTuple(nextGen)</code> Method-chaining version of <code>Gen.chainTuple</code>. <code>nextGen</code> <code>yearTupleGen.chainAsTuple(([y]) =&gt; monthGen()).chainAsTuple(([y,m]) =&gt; dayGen(y,m))</code> [Y,M,D] Class Construction <code>Gen.construct(Class, ...argGens)</code> Creates class instances using <code>new Class(...args)</code> from <code>argGens</code>. <code>Constructor</code>, <code>...argumentGenerators</code> <code>Gen.construct(Point, Gen.nat(), Gen.nat())</code> (Construct Point object)"},{"location":"combinators/#detailed-combinator-examples","title":"Detailed Combinator Examples","text":"<p>While the table above provides a quick overview, let's explore some common combinators with more illustrative examples.</p>"},{"location":"combinators/#generatormapf","title":"<code>generator.map(f)</code>","text":"<p>Transforms the output of a generator using a provided function <code>f</code>.</p> <pre><code>import { Gen } from 'jsproptest';\n\n// Generate positive integers and map them to their string representation\nconst positiveIntGen = Gen.interval(1, 1000);\nconst positiveIntStringGen = positiveIntGen.map(num =&gt; String(num));\n// Generates strings like \"1\", \"5\", \"999\"\n\n// Generate user objects with an ID and a derived email\nconst userIdGen = Gen.interval(1, 100);\nconst userObjectGen = userIdGen.map(id =&gt; ({\n  id: id,\n  email: `user${id}@example.com`\n}));\n// Generates objects like { id: 42, email: 'user42@example.com' }\n</code></pre>"},{"location":"combinators/#generatorfilterpredicate","title":"<code>generator.filter(predicate)</code>","text":"<p>Selects only the values from a generator that satisfy a given <code>predicate</code> function. Be cautious: if the predicate is too restrictive, generation might become very slow or fail if it cannot find enough valid values within a reasonable number of attempts.</p> <pre><code>import { Gen } from 'jsproptest';\n\n// Generate only even numbers between 0 and 20\nconst intervalGen = Gen.interval(0, 20);\nconst evenNumberGen = intervalGen.filter(n =&gt; n % 2 === 0);\n// Generates 0, 2, 4, ..., 20\n\n// Generate non-empty strings\nconst possiblyEmptyStringGen = Gen.string(0, 5);\nconst nonEmptyStringGen = possiblyEmptyStringGen.filter(s =&gt; s.length &gt; 0);\n// Generates strings like \"a\", \"hello\", but never \"\"\n</code></pre>"},{"location":"combinators/#generatorflatmapf-generatorchainf","title":"<code>generator.flatMap(f)</code> / <code>generator.chain(f)</code>","text":"<p>Creates a dependent generator. The function <code>f</code> takes a value produced by the initial generator and returns a new generator. This is powerful for scenarios where the generation of one value depends on another.</p> <pre><code>import { Gen } from 'jsproptest';\n\n// Generate an array whose length is also randomly generated\nconst lengthGen = Gen.interval(1, 5); // Generate a length first\nconst arrayWithRandomLengthGen = lengthGen.flatMap(len =&gt;\n  Gen.array(Gen.boolean(), len, len) // Use the generated length\n);\n// Generates arrays like [true], [false, true, false], [true, true, true, true] etc.\n\n// Generate a pair [x, y] where y &gt; x\nconst xGen = Gen.interval(0, 10);\nconst pairGen = xGen.flatMap(x =&gt;\n  Gen.interval(x + 1, 20).map(y =&gt; [x, y]) // Generate y based on x, then map to pair\n);\n// Generates pairs like [0, 1], [5, 15], [10, 11], etc.\n</code></pre>"},{"location":"combinators/#genoneofgens","title":"<code>Gen.oneOf(...gens)</code>","text":"<p>Randomly selects one of the provided generators to produce a value for each test case. To control the selection probability, you can wrap generators using <code>Gen.weightedGen</code> (see the dedicated section below).</p> <pre><code>import { Gen } from 'jsproptest';\n\n// Generate either a number or a boolean\nconst numOrBoolGen = Gen.oneOf(\n  Gen.interval(-10, 10),\n  Gen.boolean()\n);\n// Generates values like 5, true, -2, false, 0\n\n// Generate specific string constants or a generic short string\nconst specificOrGeneralStringGen = Gen.oneOf(\n  Gen.just(\"\"),        // Empty string\n  Gen.just(\"error\"),   // Specific keyword\n  Gen.string(1, 5)     // A short random string\n);\n// Generates \"\", \"error\", \"abc\", \"test\", etc.\n</code></pre>"},{"location":"combinators/#genelementofvalues","title":"<code>Gen.elementOf(...values)</code>","text":"<p>Randomly selects one value from the provided list of literal values. To control the selection probability, you can wrap values using <code>Gen.weightedValue</code> (see the dedicated section below).</p> <pre><code>import { Gen } from 'jsproptest';\n\n// Pick a specific HTTP status code\nconst statusGen = Gen.elementOf(200, 201, 400, 404, 500);\n// Generates 200, 404, 500, etc.\n\n// Pick a predefined configuration option\nconst optionGen = Gen.elementOf('read', 'write', 'admin');\n// Generates 'read', 'write', or 'admin'\n</code></pre>"},{"location":"combinators/#genweightedgengen-weight-and-genweightedvaluevalue-weight","title":"<code>Gen.weightedGen(gen, weight)</code> and <code>Gen.weightedValue(value, weight)</code>","text":"<p>Used within <code>Gen.oneOf</code> and <code>Gen.elementOf</code> respectively to influence the probability of selecting certain generators or values. The <code>weight</code> is a positive number between 0.0 and 1.0.</p> <pre><code>import { Gen } from 'jsproptest';\n\n// Generate numbers, but make 0 appear much more often\nconst weightedNumberGen = Gen.oneOf(\n  Gen.weightedGen(Gen.just(0), 0.8),          // 80% chance of getting 0\n  Gen.weightedGen(Gen.interval(1, 100), 0.2) // 20% chance of getting 1-100\n);\n// Generates 0, 0, 5, 0, 42, 0, 0, ...\n\n// Pick a character, biasing heavily towards 'a'\nconst weightedCharGen = Gen.elementOf(\n  Gen.weightedValue('a', 0.8), // 80%\n  Gen.weightedValue('b', 0.1), // 10%\n  Gen.weightedValue('c', 0.1)  // 10%\n);\n// Generates 'a' roughly 9 out of 11 times\n</code></pre>"},{"location":"combinators/#genconstructclass-arggens","title":"<code>Gen.construct(Class, ...argGens)</code>","text":"<p>Constructs instances of a <code>Class</code> by generating arguments for its constructor using the provided <code>argGens</code>.</p> <pre><code>import { Gen } from 'jsproptest';\n\nclass Point {\n  constructor(public x: number, public y: number) {}\n}\n\n// Generate Point objects with coordinates between -10 and 10\nconst pointGen = Gen.construct(\n  Point,\n  Gen.interval(-10, 10), // Generator for the 'x' argument\n  Gen.interval(-10, 10)  // Generator for the 'y' argument\n);\n// Generates Point instances like new Point(3, -5), new Point(0, 0)\n</code></pre>"},{"location":"combinators/#generatoraccumulatenextgen-minl-maxl","title":"<code>generator.accumulate(nextGen, minL, maxL)</code>","text":"<p>Builds an array incrementally. Starts with a value from the initial <code>generator</code>, then uses the <code>nextGen</code> function, which takes the last generated value, to produce the generator for the next element. This continues until the array length is between <code>minL</code> and <code>maxL</code>.</p> <pre><code>import { Gen } from 'jsproptest';\n\n// Generate an array of numbers where each number is &gt;= the previous one\nconst increasingNumbersGen = Gen.interval(0, 10) // Start with a number 0-10\n  .accumulate(\n    lastNum =&gt; Gen.interval(lastNum, lastNum + 5), // Next number &gt;= last\n    3, // Minimum length 3\n    6  // Maximum length 6\n  );\n// Generates arrays like [2, 2, 5], [8, 10, 10, 13], [0, 1, 2, 3, 4, 4]\n</code></pre>"},{"location":"combinators/#generatoraggregatenextgen-minl-maxl","title":"<code>generator.aggregate(nextGen, minL, maxL)</code>","text":"<p>Similar to <code>accumulate</code>, but <code>nextGen</code> takes the entire array generated so far and returns a generator for the next complete array state. This is less common but useful for state transformations.</p> <pre><code>import { Gen } from 'jsproptest';\n\n// Generate an array where each element is the sum of the previous two\n// (Fibonacci-like sequence, starting with [0, 1])\nconst fibLikeGen = Gen.just([0, 1]) // Start with the initial array [0, 1]\n  .aggregate(\n    currentArray =&gt; {\n      const nextVal = currentArray[currentArray.length - 1] +\n                      currentArray[currentArray.length - 2];\n      return Gen.just([...currentArray, nextVal]); // Return gen for the next array state\n    },\n    3, // Minimum length 3\n    7  // Maximum length 7\n  );\n// Generates arrays like [0, 1, 1], [0, 1, 1, 2, 3, 5], [0, 1, 1, 2, 3, 5, 8]\n</code></pre>"},{"location":"combinators/#genchaintupletuplegen-nextgen-tuplegenchainastuplenextgen","title":"<code>Gen.chainTuple(tupleGen, nextGen)</code> / <code>tupleGen.chainAsTuple(nextGen)</code>","text":"<p>Appends a new value to a tuple generated by <code>tupleGen</code>. The <code>nextGen</code> function receives the generated tuple and returns a generator for the value to append. <code>chainAsTuple</code> is the method-chaining equivalent.</p> <pre><code>import { Gen } from 'jsproptest';\n\n// Generate a pair [number, string]\nconst baseTupleGen = Gen.tuple(Gen.interval(1, 5), Gen.string(1, 3));\n\n// Generate a triple [number, string, boolean] where the boolean depends on the number\nconst extendedTupleGen = Gen.chainTuple(\n  baseTupleGen, // Starts with [number, string]\n  ([num, str]) =&gt; Gen.just(num % 2 === 0) // Appends boolean based on num\n);\n// Generates tuples like [2, \"a\", true], [5, \"xyz\", false]\n\n// Equivalent using method chaining:\nconst extendedTupleGenMethod = baseTupleGen.chainAsTuple(\n  ([num, str]) =&gt; Gen.just(num % 2 === 0)\n);\n// Generates the same kind of tuples: [4, \"b\", true], [1, \"qq\", false]\n</code></pre>"},{"location":"generators/","title":"Generators","text":"<p>Generators are the foundation of property-based testing in <code>jsproptest</code>. They are responsible for creating the diverse range of random (or sometimes specific) input data that is fed into your properties during testing. By defining how data should be generated \u2013 its type, constraints, and structure \u2013 generators allow <code>jsproptest</code> to explore the input space of your functions effectively, searching for edge cases and potential bugs that manually chosen examples might miss. Generators can range from simple primitives like booleans and numbers to complex, nested data structures built by combining other generators.</p>"},{"location":"generators/#generator-summary-table","title":"Generator Summary Table","text":"Generator Description Key Parameters Example Usage Primitives <code>Gen.boolean()</code> Generates <code>true</code> or <code>false</code>. <code>trueProb</code> (def: 0.5) <code>Gen.boolean()</code> <code>Gen.float()</code> Generates floating-point numbers (incl. <code>Infinity</code>, <code>NaN</code>). - <code>Gen.float()</code> <code>Gen.interval(min, max)</code> Generates integers in the range <code>[min, max]</code>. <code>min</code>, <code>max</code> <code>Gen.interval(0, 10)</code> <code>Gen.inRange(min, max)</code> Generates integers in the range <code>[min, max)</code>. <code>min</code>, <code>max</code> <code>Gen.inRange(0, 10)</code> <code>Gen.ascii()</code> Generates single ASCII characters (code 0-127). - <code>Gen.ascii()</code> <code>Gen.unicode()</code> Generates single Unicode characters. - <code>Gen.unicode()</code> <code>Gen.printableAscii()</code> Generates single printable ASCII characters. - <code>Gen.printableAscii()</code> <code>Gen.string(minL, maxL)</code> Generates strings (defaults to ASCII). <code>minLength</code> (def: 0), <code>maxLength</code> (def: 10) <code>Gen.string(0, 5)</code> <code>Gen.asciiString(...)</code> Generates strings containing only ASCII chars (0-127). <code>minLength</code> (def: 0), <code>maxLength</code> (def: 10) <code>Gen.asciiString(1, 8)</code> <code>Gen.unicodeString(...)</code> Generates strings containing Unicode chars. <code>minLength</code> (def: 0), <code>maxLength</code> (def: 10) <code>Gen.unicodeString(1, 8)</code> <code>Gen.printableAsciiString(...)</code> Generates strings containing only printable ASCII chars. <code>minLength</code> (def: 0), <code>maxLength</code> (def: 10) <code>Gen.printableAsciiString(5, 5)</code> Containers <code>Gen.array(elem, minL, maxL)</code> Generates arrays with elements from <code>elem</code>. <code>elementGen</code>, <code>minLength</code> (def: 0), <code>maxLength</code> (def: 10) <code>Gen.array(Gen.boolean(), 2, 4)</code> <code>Gen.uniqueArray(elem, minL, maxL)</code> Generates arrays with unique elements from <code>elem</code>. <code>elementGen</code>, <code>minLength</code> (def: 0), <code>maxLength</code> (def: 10) <code>Gen.uniqueArray(Gen.interval(1, 10), 3, 3)</code> <code>Gen.set(elem, minS, maxS)</code> Generates <code>Set</code> objects with elements from <code>elem</code>. <code>elementGen</code>, <code>minSize</code> (def: 0), <code>maxSize</code> (def: 10) <code>Gen.set(Gen.interval(1, 3), 1, 3)</code> <code>Gen.dictionary(keyGen, valGen, minS, maxS)</code> Generates objects with keys from <code>keyGen</code> and values from <code>valGen</code>. <code>keyGen</code>, <code>valueGen</code>, <code>minSize</code> (def: 0), <code>maxSize</code> (def: 10) <code>Gen.dictionary(Gen.string(1, 2), Gen.interval(0, 5), 2, 5)</code> <code>Gen.tuple(...gens)</code> Generates fixed-size arrays (tuples) from <code>gens</code>. <code>...elementGens</code> <code>Gen.tuple(Gen.number(), Gen.string())</code> Special <code>Gen.just(value)</code> Always generates the provided <code>value</code>. <code>value</code> <code>Gen.just(null)</code> <code>Gen.lazy(() =&gt; value)</code> Defers execution of a function to produce <code>value</code> until needed. <code>valueFactory: () =&gt; T</code> <code>Gen.lazy(() =&gt; expensiveCalculation())</code> <p>(Defaults for length/size are typically 0 and 10, but check implementation for specifics)</p>"},{"location":"generators/#examples","title":"Examples","text":"<p>Here are some more detailed examples illustrating how to use various generators:</p> <p><code>Gen.float()</code></p> <p>Generates standard floating-point numbers, but also includes special values crucial for testing numerical robustness:</p> <pre><code>// Can produce: 3.14, -0.0, Infinity, -Infinity, NaN\nGen.float();\n</code></pre> <p><code>Gen.string()</code></p> <p>Generates strings. You can control the character set and length.</p> <pre><code>// Generates ASCII strings of length 5 to 10\nGen.string(5, 10); // Default character set is printable ASCII\n\n// Generates Unicode strings of exactly length 3\nGen.unicodeString(3, 3);\n\n// Generates printable ASCII strings of length 0 to 5\nGen.printableAsciiString(0, 5);\n</code></pre> <p><code>Gen.array()</code></p> <p>Generates arrays where each element is created by the provided element generator.</p> <pre><code>// Generates arrays of 2 to 5 booleans\n// e.g., [true, false], [false, false, true, true]\nGen.array(Gen.boolean(), 2, 5);\n\n// Generates arrays of 0 to 10 strings, each 1-3 chars long\nGen.array(Gen.string(1, 3), 0, 10);\n</code></pre> <p><code>Gen.dictionary()</code></p> <p>Generates objects (dictionaries) with string keys generated by <code>keyGen</code> and values generated by the provided <code>valueGen</code>.</p> <pre><code>// Generates objects with 1 to 3 key-value pairs,\n// where keys are 1-char strings (a-z) and values are floats.\n// e.g., { \"a\": 1.2, \"b\": -Infinity }, { \"z\": 10.0 }\nconst keyGen = Gen.string(1, 1).map(s =&gt; String.fromCharCode(97 + (s.charCodeAt(0) % 26))) // Generate a-z keys\nGen.dictionary(keyGen, Gen.float(), 1, 3);\n</code></pre> <p><code>Gen.tuple()</code></p> <p>Generates fixed-size arrays (tuples) with elements of potentially different types, determined by the sequence of generators provided.</p> <pre><code>// Generates pairs of [boolean, number]\n// e.g., [true, 15], [false, -3.1]\nGen.tuple(Gen.boolean(), Gen.float());\n\n// Generates triples of [string, integer, string]\n// e.g., [\"hello\", 5, \"world\"], [\"\", -100, \"test\"]\nGen.tuple(Gen.string(0, 5), Gen.interval(-100, 100), Gen.string(1, 4));\n</code></pre> <p><code>Gen.just(value)</code></p> <p>A generator that always produces the exact <code>value</code> provided. Useful for including specific edge cases or constants in your generated data mix (often used with <code>Gen.oneOf</code>).</p> <pre><code>// Always generates the number 42\nGen.just(42);\n\n// Always generates null\nGen.just(null);\n</code></pre> <p><code>Gen.lazy(() =&gt; value)</code></p> <p>Defers the execution of a function that produces a value <code>T</code>. The function is only called when the generator's <code>generate</code> method is invoked. This is useful for delaying expensive computations or breaking simple circular dependencies in definitions, but note that the provided function <code>() =&gt; T</code> does not receive a <code>Random</code> instance, making this unsuitable for defining randomly generated recursive structures.</p> <pre><code>// Example: Deferring an expensive calculation\nfunction expensiveCalculation(): number {\n  // ... imagine complex logic here ...\n  return result;\n}\n\nconst lazyResultGen = Gen.lazy(expensiveCalculation);\n</code></pre> <p>Beyond the built-in generators, <code>jsproptest</code> provides combinators: functions that transform or combine existing generators to create new, more complex ones. This is how you build generators for your specific data types and constraints.</p> <p>These combinators are essential tools for tailoring data generation precisely to your testing needs. For a comprehensive guide on how to use them, see the Combinators documentation.</p>"},{"location":"properties/","title":"Properties","text":"<p>Properties define the expected behavior of your code over a range of inputs.</p>"},{"location":"properties/#defining-properties-with-new-property","title":"Defining Properties with <code>new Property(...)</code>","text":"<ul> <li> <p><code>new Property&lt;TArgs extends any[]&gt;(predicate: (...args: TArgs) =&gt; boolean | void)</code>: Creates a property object explicitly. The <code>predicate</code> function receives arguments generated according to the generators passed to <code>forAll</code>.</p> <ul> <li>If the predicate returns <code>false</code> or throws an error, the property fails.</li> <li>If the predicate returns <code>true</code> or <code>void</code> (implicitly returns <code>undefined</code>), the property passes for that input.</li> </ul> <pre><code>// Property: The sum of two non-negative numbers is non-negative\nconst sumProperty = new Property((a: number, b: number) =&gt; {\n    expect(a + b).toBeGreaterThanOrEqual(0); // Using jest assertions\n    // Or: return a + b &gt;= 0;\n});\n\n// Running the property\nsumProperty.setNumRuns(200).forAll(Gen.interval(0, 100), Gen.interval(0, 100));\n</code></pre> </li> <li> <p><code>property.setNumRuns(n: number)</code>: Configures the number of random test cases to execute when <code>forAll</code> is called on a <code>Property</code> instance. Returns the <code>Property</code> instance for chaining.</p> </li> <li> <p><code>property.example(...args: any[])</code>: Runs the property's predicate once with the explicitly provided <code>args</code>. Useful for debugging specific edge cases.</p> <pre><code>const prop = new Property((a: number, b: number) =&gt; a &gt; b);\nprop.example(5, 3); // Runs the predicate with a=5, b=3\nprop.example(3, 5); // returns false\n</code></pre> </li> </ul>"},{"location":"properties/#defining-and-running-properties-with-forall-standalone-function","title":"Defining and Running Properties with <code>forAll(...)</code> (Standalone Function)","text":"<ul> <li> <p><code>forAll&lt;TArgs extends any[]&gt;(predicate: (...args: TArgs) =&gt; boolean | void, ...gens: { [K in keyof TArgs]: Arbitrary&lt;TArgs[K]&gt; })</code>: This is the most common and concise way to define and immediately check a property. It implicitly creates and runs the property. You don't need to manually create a <code>Property</code> object.</p> <p><pre><code>// Property: Reversing an array twice yields the original array\nit('should return original array after double reverse', () =&gt; {\n    forAll(\n        (arr: string[]) =&gt; {\n            // Predicate using Jest assertions\n            expect([...arr].reverse().reverse()).toEqual(arr);\n        },\n        Gen.array(Gen.string(0, 5), 0, 10) // Generator for the 'arr' argument\n    ); // Runs the test immediately (default 100 times)\n});\n\n// Property: String concatenation length\nit('should have correct length after concatenation', () =&gt; {\n    forAll(\n        (s1: string, s2: string) =&gt; {\n            // Predicate returning a boolean\n            return (s1 + s2).length === s1.length + s2.length;\n        },\n        Gen.string(0, 20), // Generator for s1\n        Gen.string(0, 20)  // Generator for s2\n    );\n});\n\n// Property: Absolute value is non-negative\nit('should have non-negative absolute value', () =&gt; {\n    forAll(\n        (num: number) =&gt; {\n            expect(Math.abs(num)).toBeGreaterThanOrEqual(0);\n        },\n        Gen.float() // Use float generator\n    );\n});\n\n// Property: Tuple elements follow constraints\nit('should generate tuples with correct constraints', () =&gt; {\n    forAll(\n        ([num, bool]: [number, boolean]) =&gt; {\n            expect(num).toBeGreaterThanOrEqual(0);\n            expect(num).toBeLessThanOrEqual(10);\n            expect(typeof bool).toBe('boolean');\n        },\n        Gen.tuple(Gen.interval(0, 10), Gen.boolean()) // Tuple generator\n    );\n});\n\n// Property: Nested forAll (less common, but possible)\nit('should handle nested properties', () =&gt; {\n    expect(() =&gt;\n        forAll((a: number) =&gt; { // Outer property\n            forAll((b: number) =&gt; { // Inner property\n                // This property fails for large 'a' and small 'b'\n                expect(a &gt; 80 || b &lt; 40).toBe(true)\n            }, Gen.interval(0, 1000)) // Generator for 'b'\n        }, Gen.interval(0, 1000)) // Generator for 'a'\n    ).toThrow(); // We expect this nested structure to fail and throw\n});\n</code></pre> Note: The standalone <code>forAll</code> runs a default number of times (e.g., 100). To configure the number of runs, you need to use the <code>new Property(...).setNumRuns(...).forAll(...)</code> approach. </p> </li> </ul>"},{"location":"shrinking/","title":"Shrinking","text":"<p>When <code>forAll</code> (either standalone or called on a <code>Property</code> instance) detects a failing test case, it automatically tries to \"shrink\" the failing input to a simpler version that still causes the failure. This helps pinpoint the root cause.</p> <ul> <li>Shrinking explores smaller integers, shorter strings/arrays, subsets of sets, and simpler structures based on how the generators were defined and combined.</li> <li>The error message thrown by <code>forAll</code> on failure typically includes the original failing input and the final, shrunk failing input.</li> </ul> <pre><code>// Example where shrinking is useful (using standalone forAll)\nit('fails and shrinks with standalone forAll', () =&gt; {\n    // Generator for pairs [a, b] where a &lt;= b\n    const pairGen = Gen.interval(0, 1000)\n        .flatMap(a =&gt; Gen.tuple(Gen.just(a), Gen.interval(a, 1000)));\n\n    expect(() =&gt;\n        forAll(\n            (tup: [number, number]) =&gt; {\n                // This property fails if the difference is large\n                return tup[1] - tup[0] &lt;= 5;\n            },\n            pairGen\n        )\n    ).toThrow(\n        // The error message will likely show a shrunk example,\n        // e.g., \"property failed (simplest args found by shrinking): ...\"\n    );\n});\n</code></pre>"},{"location":"stateful-testing/","title":"Stateful Testing","text":"<p>Stateful testing involves defining a sequence of actions or commands that can be applied to a system under test and verifying properties or invariants about the system's state after executing these sequences.</p> <p><code>jsproptest</code> provides utilities for defining state machines and generating sequences of commands to effectively test stateful systems. It allows you to model the state of your system, define actions that change the state, and automatically run sequences of these actions to find bugs.</p>"},{"location":"stateful-testing/#core-concepts","title":"Core Concepts","text":"<p>Stateful testing in <code>jsproptest</code> revolves around the <code>StatefulProperty</code> class, which orchestrates the test execution. Here are the key components:</p> <ol> <li>Initial State (<code>ObjectType</code>): You need a generator (<code>Generator&lt;ObjectType&gt;</code>) that produces the initial state of the system under test for each test run.</li> <li>Actions (<code>Action</code> or <code>SimpleAction</code>): Actions represent operations that modify the system's state.<ul> <li><code>SimpleAction</code>: Used when you don't need an explicit model. It takes a function <code>(obj: ObjectType) =&gt; void</code>.</li> <li><code>Action</code>: Used when you have a model. It takes a function <code>(obj: ObjectType, model: ModelType) =&gt; void</code> and updates both the real object and the model.</li> </ul> </li> <li>Model (<code>ModelType</code>, Optional): A simplified representation of the system's state. It's used to verify the correctness of the actual system's state after each action.</li> <li>Model Factory (<code>modelFactory</code>, Optional): A function <code>(obj: ObjectType) =&gt; ModelType</code> that creates the initial model state based on the initial object state. Required if using a model.</li> <li>Action Generation (<code>actionGenFactory</code> or <code>simpleActionGenFactory</code>): A factory function that returns a generator for the next action based on the current state of the object (and model, if applicable).<ul> <li><code>SimpleActionGenFactory</code>: <code>(obj: ObjectType) =&gt; Generator&lt;SimpleAction&lt;ObjectType&gt;&gt;</code></li> <li><code>ActionGenFactory</code>: <code>(obj: ObjectType, model: ModelType) =&gt; Generator&lt;Action&lt;ObjectType, ModelType&gt;&gt;</code> <code>jsproptest</code> provides helpers like <code>Gen.simpleActionOf</code> and <code>Gen.actionOf</code> to combine multiple action generators.</li> </ul> </li> </ol>"},{"location":"stateful-testing/#creating-a-stateful-property","title":"Creating a Stateful Property","text":"<p>You typically use factory functions to create a <code>StatefulProperty</code>:</p> <ul> <li> <p><code>simpleStatefulProperty&lt;ObjectType&gt;(initialGen, simpleActionGenFactory)</code>: Use this when you don't need an explicit model. Checks are usually performed within the <code>SimpleAction</code> implementations (e.g., asserting invariants after an operation).</p> <pre><code>import { Gen, simpleStatefulProperty, SimpleAction } from 'jsproptest';\n\ntype MySystem = number[];\n\n// Generator for the initial state (e.g., an empty array)\nconst initialGen = Gen.just([]);\n\n// Action: Add an element\nconst addActionGen = Gen.integer().map(val =&gt;\n    new SimpleAction((arr: MySystem) =&gt; {\n        const oldLength = arr.length;\n        arr.push(val);\n        // Assert invariant within the action\n        expect(arr.length).toBe(oldLength + 1);\n    })\n);\n\n// Action: Clear the array\nconst clearActionGen = Gen.just(\n    new SimpleAction((arr: MySystem) =&gt; {\n        arr.length = 0;\n        expect(arr.length).toBe(0);\n    })\n);\n\n// Combine action generators\nconst actionFactory = Gen.oneOf(addActionGen, clearActionGen)\n\n// Create the property\nconst prop = simpleStatefulProperty(initialGen, actionFactory);\n\n// Run the test\nprop.go();\n</code></pre> </li> <li> <p><code>statefulProperty&lt;ObjectType, ModelType&gt;(initialGen, modelFactory, actionGenFactory)</code>: Use this when you want to maintain a separate model to verify the system's behavior against.</p> <pre><code>import { Gen, statefulProperty, Action } from 'jsproptest';\n\ntype MySystem = number[];\ntype MyModel = { expectedCount: number };\n\n// Initial state generator\nconst initialGen = Gen.array(Gen.integer(), 0, 10);\n\n// Model factory\nconst modelFactory = (arr: MySystem): MyModel =&gt; ({ expectedCount: arr.length });\n\n// Action: Add element (updates object and model)\nconst addActionGen = Gen.integer().map(val =&gt;\n    new Action((arr: MySystem, model: MyModel) =&gt; {\n        arr.push(val);\n        model.expectedCount++;\n        // Check consistency (optional, can also use postCheck)\n        expect(arr.length).toBe(model.expectedCount);\n    })\n);\n\n// Action: Remove element (updates object and model)\nconst removeActionGen = Gen.just(\n    new Action((arr: MySystem, model: MyModel) =&gt; {\n        if (arr.length === 0) return; // Precondition\n        arr.pop();\n        model.expectedCount--;\n        expect(arr.length).toBe(model.expectedCount);\n    })\n);\n\n// Action generator factory\nconst actionFactory = Gen.simpleActionOf(addActionGen, Gen.weightedValue(removeActionGen, 0.1))\n\n// Create the property\nconst prop = statefulProperty(initialGen, modelFactory, actionFactory);\n\n// Run the test\nprop.go();\n</code></pre> </li> </ul>"},{"location":"stateful-testing/#configuration","title":"Configuration","text":"<p>The <code>StatefulProperty</code> instance provides several methods for configuration:</p> <ul> <li><code>setSeed(string)</code>: Sets the initial seed for the random number generator for reproducible tests.</li> <li><code>setNumRuns(number)</code>: Sets the number of test sequences to execute (default: 100).</li> <li><code>setMinActions(number)</code> / <code>setMaxActions(number)</code>: Sets the minimum and maximum number of actions per sequence (default: 1-100).</li> <li><code>setVerbosity(boolean)</code>: Enables/disables verbose logging during execution.</li> <li><code>setOnStartup(() =&gt; void)</code>: Sets a function to run before each test sequence.</li> <li><code>setOnCleanup(() =&gt; void)</code>: Sets a function to run after each successful test sequence.</li> <li><code>setPostCheck((obj: ObjectType, model: ModelType) =&gt; void)</code>: Sets a function to run after all actions in a sequence have completed successfully. Useful for final state validation. You can also use <code>setPostCheckWithoutModel((obj: ObjectType) =&gt; void)</code>.</li> </ul>"},{"location":"stateful-testing/#shrinking","title":"Shrinking","text":"<p>If a test sequence fails (an action throws an error or the <code>postCheck</code> fails), <code>jsproptest</code> automatically tries to shrink the test case to find a minimal reproduction. It does this by:</p> <ol> <li>Shrinking the Action Sequence: Trying shorter sequences or simpler actions.</li> <li>Shrinking the Initial State: Trying simpler versions of the initial state generated by <code>initialGen</code>.</li> </ol> <p>The goal is to present the simplest possible initial state and sequence of actions that trigger the failure, making debugging easier. The error message will report the shrunk arguments if successful.</p>"}]}