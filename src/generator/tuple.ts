import { Generator, Arbitrary } from '../Generator'
import { Random } from '../Random'
import { Shrinkable } from '../Shrinkable'
import { shrinkableTuple } from '../shrinker/tuple'

/** Helper type to extract the value type `T` from a `Generator<T>`. */
type GenValueType<Gen> = Gen extends Generator<infer T> ? T : never

/**
 * Given a tuple of Generators, maps it to a tuple of the corresponding generated value types.
 * e.g., `[Generator<A>, Generator<B>]` becomes `[A, B]`
 */
export type GenValueTypes<Gens extends Generator<unknown>[]> = { [K in keyof Gens]: GenValueType<Gens[K]> }

// Maps a tuple of Generators to a tuple of Shrinkables of their corresponding value types.
// e.g., `[Generator<A>, ..., Generator<B>]` becomes `[Shrinkable<A>,...,Shrinkable<B>]`
type ShrsFromGens<Gens> = {
    [K in keyof Gens]: Shrinkable<GenValueType<Gens[K]>>
}

/**
 * Creates a generator that produces tuples by combining the results of the provided element generators.
 * The resulting tuple's type is derived from the types generated by the input generators.
 *
 * @param elemGens - A rest parameter array of `Generator` instances.
 * @returns A `Generator` that produces tuples where each element corresponds to the value generated by the respective generator in `elemGens`.
 */
export function TupleGen<Gens extends Generator<unknown>[]>(...elemGens: Gens): Generator<GenValueTypes<Gens>> {
    type Ts = GenValueTypes<Gens>
    return new Arbitrary<Ts>((rand: Random) => {
        const shrinkables: Shrinkable<unknown>[] = elemGens.map(elemGen => elemGen.generate(rand)) as ShrsFromGens<Gens>
        // The resulting Shrinkable tuple combines the individual shrinkable values.
        return shrinkableTuple(...shrinkables) as Shrinkable<GenValueTypes<Gens>>
    })
}
